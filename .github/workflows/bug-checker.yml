name: Bug Checker Agent

# Analyzes open bugs to check if fixes exist (via linked PRs or codebase analysis)
on:
  schedule:
    - cron: "0 9 * * 1" # Every Monday at 9 AM UTC
  workflow_dispatch: # Allow manual trigger
    inputs:
      dry_run:
        description: "Dry run mode (only report, don't comment)"
        required: false
        default: false
        type: boolean
      days_threshold:
        description: "Only check issues older than N days"
        required: false
        default: "30"
        type: string
      max_bugs_to_analyze:
        description: "Max bugs for Claude to analyze (controls API cost)"
        required: false
        default: "10"
        type: string
      use_claude:
        description: "Use Claude to analyze bugs without linked PRs"
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  # Job 1: Collect bugs and check for linked PRs
  collect-bugs:
    runs-on: ubuntu-latest
    outputs:
      bugs_with_prs: ${{ steps.check.outputs.bugs_with_prs }}
      bugs_without_prs: ${{ steps.check.outputs.bugs_without_prs }}
      bugs_for_claude: ${{ steps.check.outputs.bugs_for_claude }}
    steps:
      - name: Collect and categorize bugs
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const daysThreshold = parseInt('${{ inputs.days_threshold }}' || '30');
            const maxBugsToAnalyze = parseInt('${{ inputs.max_bugs_to_analyze }}' || '10');

            console.log(`Configuration: days_threshold=${daysThreshold}, max_bugs=${maxBugsToAnalyze}`);

            // Get all open issues with 'bug' label
            const openBugs = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'bug',
              per_page: 100
            });

            console.log(`Found ${openBugs.length} open bugs`);

            const now = new Date();
            const bugsWithPRs = [];
            const bugsWithoutPRs = [];

            for (const issue of openBugs) {
              // Skip PRs (GitHub API returns PRs as issues too)
              if (issue.pull_request) continue;

              // Skip issues newer than threshold
              const issueAge = (now - new Date(issue.created_at)) / (1000 * 60 * 60 * 24);
              if (issueAge < daysThreshold) {
                console.log(`Skipping #${issue.number} - too recent (${Math.floor(issueAge)} days old)`);
                continue;
              }

              console.log(`\nChecking issue #${issue.number}: ${issue.title}`);

              // Search for merged PRs that reference this issue
              const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:pr is:merged "#${issue.number}"`;
              const searchResults = await github.rest.search.issuesAndPullRequests({
                q: searchQuery,
                per_page: 10
              });

              // Filter PRs that actually reference this issue (use regex for exact match)
              const linkedPRs = [];
              for (const pr of searchResults.data.items) {
                const body = (pr.body || '').toLowerCase();
                const title = (pr.title || '').toLowerCase();
                const text = `${title} ${body}`;

                // Regex with word boundary to prevent #12 matching #123
                const pattern = new RegExp(`(fixes|fix|closes|close|resolves|resolve|fixed)?\\s*#${issue.number}(?!\\d)`, 'i');

                if (pattern.test(text)) {
                  linkedPRs.push({
                    number: pr.number,
                    title: pr.title,
                    url: pr.html_url
                  });
                }
              }

              const bugInfo = {
                number: issue.number,
                title: issue.title,
                body: issue.body?.substring(0, 2000) || '', // Limit body size
                url: issue.html_url,
                age_days: Math.floor(issueAge)
              };

              if (linkedPRs.length > 0) {
                bugsWithPRs.push({ ...bugInfo, linkedPRs });
                console.log(`  -> Has ${linkedPRs.length} linked PR(s)`);
              } else {
                bugsWithoutPRs.push(bugInfo);
                console.log(`  -> No linked PRs found`);
              }
            }

            // Select bugs for Claude analysis (oldest first, limited count)
            const bugsForClaude = bugsWithoutPRs
              .sort((a, b) => b.age_days - a.age_days)
              .slice(0, maxBugsToAnalyze);

            console.log(`\n${'='.repeat(50)}`);
            console.log(`Bugs with linked PRs: ${bugsWithPRs.length}`);
            console.log(`Bugs without linked PRs: ${bugsWithoutPRs.length}`);
            console.log(`Bugs selected for Claude analysis: ${bugsForClaude.length}`);

            core.setOutput('bugs_with_prs', JSON.stringify(bugsWithPRs));
            core.setOutput('bugs_without_prs', JSON.stringify(bugsWithoutPRs));
            core.setOutput('bugs_for_claude', JSON.stringify(bugsForClaude));

  # Job 2: Comment on bugs with linked PRs (no AI needed)
  comment-linked-bugs:
    needs: collect-bugs
    if: ${{ inputs.dry_run != true }}
    runs-on: ubuntu-latest
    steps:
      - name: Comment on bugs with linked PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const bugsWithPRs = JSON.parse('${{ needs.collect-bugs.outputs.bugs_with_prs }}');
            const now = new Date();
            const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString();

            for (const bug of bugsWithPRs) {
              // Check if we already commented recently
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: bug.number,
                since: thirtyDaysAgo,
                per_page: 100
              });

              if (comments.data.some(c => c.body.includes('Bug Checker Agent'))) {
                console.log(`Skipping #${bug.number} - already commented`);
                continue;
              }

              const prList = bug.linkedPRs.map(pr => `- #${pr.number}: ${pr.title}`).join('\n');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: bug.number,
                body: `## ðŸ” Bug Checker Agent Report

            **Status:** Potentially fixed via linked PR(s)

            This issue appears to have been addressed by the following merged PR(s):

            ${prList}

            **Action requested:** Please verify if this bug has been fixed and close this issue if appropriate.

            ---
            _Automated message from Bug Checker Agent_`
              });
              console.log(`Commented on #${bug.number}`);
            }

  # Job 3: Use Claude to analyze bugs without linked PRs
  analyze-with-claude:
    needs: collect-bugs
    if: ${{ inputs.use_claude == true && needs.collect-bugs.outputs.bugs_for_claude != '[]' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Analyze bugs with Claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          direct_prompt: |
            You are a Bug Checker Agent analyzing open bugs to determine if they have been fixed.

            ## Your Task
            Analyze each bug below and search the codebase to determine if a fix likely exists.

            ## Bugs to Analyze
            ${{ needs.collect-bugs.outputs.bugs_for_claude }}

            ## Instructions
            For each bug:
            1. Read the bug title and description
            2. Identify keywords, file names, function names, or error messages mentioned
            3. Search the codebase for relevant code
            4. Determine if the bug appears to be fixed based on:
               - Error handling that addresses the issue
               - Code changes that fix the described behavior
               - Features that now work differently
               - Code that was removed/refactored

            ## Output Format
            Create a summary comment on each issue with your findings:
            - If likely fixed: Explain what code you found that addresses the issue
            - If unclear: Note what you checked and why it's inconclusive
            - If not fixed: Confirm the issue likely still exists

            Use the GitHub issue comment tool to post your findings on each issue.
            Start each comment with "## ðŸ¤– Bug Checker Agent - Code Analysis"

            ${{ inputs.dry_run == true && 'DRY RUN MODE: Just log your findings, do not post comments.' || '' }}

  # Job 4: Create summary
  summary:
    needs: [collect-bugs, comment-linked-bugs, analyze-with-claude]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Create workflow summary
        uses: actions/github-script@v7
        with:
          script: |
            const bugsWithPRs = JSON.parse('${{ needs.collect-bugs.outputs.bugs_with_prs }}' || '[]');
            const bugsWithoutPRs = JSON.parse('${{ needs.collect-bugs.outputs.bugs_without_prs }}' || '[]');
            const bugsForClaude = JSON.parse('${{ needs.collect-bugs.outputs.bugs_for_claude }}' || '[]');

            const summary = `
            ## ðŸ” Bug Checker Agent Summary

            | Category | Count |
            |----------|-------|
            | Bugs with linked PRs | ${bugsWithPRs.length} |
            | Bugs without linked PRs | ${bugsWithoutPRs.length} |
            | Bugs analyzed by Claude | ${bugsForClaude.length} |

            ### Bugs with Linked PRs (Potentially Fixed)
            ${bugsWithPRs.length > 0
              ? bugsWithPRs.map(b => `- #${b.number}: ${b.title}`).join('\n')
              : '_None found_'}

            ### Bugs Analyzed by Claude
            ${bugsForClaude.length > 0
              ? bugsForClaude.map(b => `- #${b.number}: ${b.title} (${b.age_days} days old)`).join('\n')
              : '_None selected for analysis_'}

            ### Bugs Not Analyzed (No linked PRs, not selected for Claude)
            ${bugsWithoutPRs.filter(b => !bugsForClaude.find(c => c.number === b.number)).length > 0
              ? bugsWithoutPRs
                  .filter(b => !bugsForClaude.find(c => c.number === b.number))
                  .map(b => `- #${b.number}: ${b.title}`)
                  .join('\n')
              : '_None_'}
            `;

            await core.summary.addRaw(summary).write();
            console.log(summary);
