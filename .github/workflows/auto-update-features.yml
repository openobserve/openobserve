name: Auto-update Features JSON

on:
  pull_request:
    types: [opened, edited]
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  update-features:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse PR description and update features.json
        uses: actions/github-script@v7
        id: parse-feature
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Get PR body
            const prBody = context.payload.pull_request.body || '';

            // Check if PR contains feature update section
            const featureRegex = /<!-- FEATURE_UPDATE_START -->([\s\S]*?)<!-- FEATURE_UPDATE_END -->/;
            const match = prBody.match(featureRegex);

            if (!match) {
              console.log('No feature update section found in PR description');
              core.setOutput('has_feature', 'false');
              return;
            }

            console.log('Feature update section found!');
            core.setOutput('has_feature', 'true');

            // Parse the feature data from the matched section
            const featureSection = match[1].trim();

            // Results tracking for multiple features
            const results = [];
            let allSuccess = true;
            let errorMessages = [];

            try {
              // Try to parse as JSON (single object or array)
              let featureDataList = [];
              const jsonMatch = featureSection.match(/```json\s*([\s\S]*?)\s*```/);

              if (jsonMatch) {
                const parsedData = JSON.parse(jsonMatch[1]);
                // Support both single object and array format
                featureDataList = Array.isArray(parsedData) ? parsedData : [parsedData];
              } else {
                // Parse key-value format (single feature only)
                const featureData = {};
                const lines = featureSection.split('\n');
                for (const line of lines) {
                  const kvMatch = line.match(/^\s*-?\s*\*?\*?(\w+)\*?\*?\s*:\s*(.+)$/);
                  if (kvMatch) {
                    const key = kvMatch[1].toLowerCase().replace(/\s+/g, '_');
                    let value = kvMatch[2].trim();

                    // Handle boolean values
                    if (value === 'true' || value === 'yes') value = true;
                    if (value === 'false' || value === 'no') value = false;

                    // Handle nested objects (availability)
                    if (key.startsWith('availability_')) {
                      if (!featureData.availability) featureData.availability = {};
                      const edition = key.replace('availability_', '');
                      featureData.availability[edition] = value;
                    } else {
                      featureData[key] = value;
                    }
                  }
                }
                featureDataList = [featureData];
              }

              console.log(`Processing ${featureDataList.length} feature(s)`);

              // Read existing features.json
              const featuresPath = path.join(process.env.GITHUB_WORKSPACE, 'web/src/constants/features.json');
              const featuresContent = fs.readFileSync(featuresPath, 'utf8');
              const featuresJson = JSON.parse(featuresContent);

              // Process each feature
              for (let i = 0; i < featureDataList.length; i++) {
                const featureData = featureDataList[i];
                const result = { index: i + 1 };

                try {
                  console.log(`\nProcessing feature ${i + 1}:`, JSON.stringify(featureData, null, 2));

                  // Validate required fields
                  if (!featureData.id) {
                    throw new Error(`Feature ${i + 1}: Missing required field: id`);
                  }
                  if (!featureData.availability) {
                    throw new Error(`Feature ${i + 1}: Missing required field: availability`);
                  }
                  if (!featureData.availability.opensource ||
                      !featureData.availability.enterprise ||
                      !featureData.availability.cloud) {
                    throw new Error(`Feature ${i + 1}: Missing required availability fields (opensource, enterprise, cloud)`);
                  }

                  result.id = featureData.id;

                  // Check if feature already exists
                  const existingIndex = featuresJson.features.findIndex(f => f.id === featureData.id);

                  if (existingIndex >= 0) {
                    console.log(`Updating existing feature: ${featureData.id}`);
                    // Preserve any fields not in the update
                    featuresJson.features[existingIndex] = { ...featuresJson.features[existingIndex], ...featureData };
                    result.action = 'updated';
                  } else {
                    console.log(`Adding new feature: ${featureData.id}`);

                    // Determine position
                    let position = featureData.position || 'end';
                    delete featureData.position; // Remove position field from feature data

                    if (position === 'start') {
                      featuresJson.features.unshift(featureData);
                    } else if (typeof position === 'number') {
                      featuresJson.features.splice(position, 0, featureData);
                    } else {
                      featuresJson.features.push(featureData);
                    }
                    result.action = 'added';
                  }

                  result.success = true;
                  console.log(`‚úÖ Feature ${featureData.id} ${result.action} successfully`);

                } catch (featureError) {
                  console.error(`‚ùå Error processing feature ${i + 1}:`, featureError.message);
                  result.success = false;
                  result.error = featureError.message;
                  allSuccess = false;
                  errorMessages.push(featureError.message);
                }

                results.push(result);
              }

              // Write updated features.json only if at least one feature succeeded
              const successCount = results.filter(r => r.success).length;
              if (successCount > 0) {
                fs.writeFileSync(featuresPath, JSON.stringify(featuresJson, null, 2) + '\n', 'utf8');
                console.log(`\n‚úÖ Successfully processed ${successCount}/${results.length} feature(s)`);
              }

              // Set outputs
              core.setOutput('results', JSON.stringify(results));
              core.setOutput('success', allSuccess ? 'true' : 'partial');
              core.setOutput('total_count', results.length.toString());
              core.setOutput('success_count', successCount.toString());
              core.setOutput('feature_ids', results.filter(r => r.success).map(r => r.id).join(', '));

              if (!allSuccess) {
                core.setOutput('errors', errorMessages.join('; '));
              }

            } catch (error) {
              console.error('Error parsing feature data:', error.message);
              core.setOutput('success', 'false');
              core.setOutput('error', error.message);
              throw error;
            }

      - name: Check for translation keys
        if: steps.parse-feature.outputs.success == 'true' || steps.parse-feature.outputs.success == 'partial'
        id: check-translations
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const results = JSON.parse('${{ steps.parse-feature.outputs.results }}');
            const translationResults = [];

            // Check if translation exists in en.json
            const enJsonPath = path.join(process.env.GITHUB_WORKSPACE, 'web/src/locales/languages/en.json');
            const enJson = JSON.parse(fs.readFileSync(enJsonPath, 'utf8'));

            for (const result of results) {
              if (result.success && result.id) {
                const expectedKey = `feature_${result.id}`;
                const hasTranslation = enJson.about && enJson.about[expectedKey];
                translationResults.push({
                  id: result.id,
                  key: `about.${expectedKey}`,
                  exists: hasTranslation
                });
              }
            }

            core.setOutput('translation_results', JSON.stringify(translationResults));
            const allHaveTranslations = translationResults.every(t => t.exists);
            core.setOutput('all_translations_exist', allHaveTranslations ? 'true' : 'false');

      - name: Commit changes
        if: steps.parse-feature.outputs.success == 'true' || steps.parse-feature.outputs.success == 'partial'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if git diff --quiet web/src/constants/features.json; then
            echo "No changes to commit"
            exit 0
          fi

          git add web/src/constants/features.json
          git commit -m "chore: auto-update features.json from PR description

          Features processed: ${{ steps.parse-feature.outputs.success_count }}/${{ steps.parse-feature.outputs.total_count }}
          Feature IDs: ${{ steps.parse-feature.outputs.feature_ids }}

          ü§ñ Automated update via GitHub Actions"

          git push

      - name: Comment on PR - Success
        if: steps.parse-feature.outputs.success == 'true' || steps.parse-feature.outputs.success == 'partial'
        uses: actions/github-script@v7
        with:
          script: |
            const results = JSON.parse('${{ steps.parse-feature.outputs.results }}');
            const translationResults = JSON.parse('${{ steps.check-translations.outputs.translation_results }}');
            const totalCount = parseInt('${{ steps.parse-feature.outputs.total_count }}');
            const successCount = parseInt('${{ steps.parse-feature.outputs.success_count }}');
            const isPartial = '${{ steps.parse-feature.outputs.success }}' === 'partial';

            let message = '';

            // Header
            if (isPartial) {
              message += `### ‚ö†Ô∏è Features Partially Updated (${successCount}/${totalCount} succeeded)\n\n`;
            } else {
              message += `### ‚úÖ ${totalCount > 1 ? 'Multiple Features' : 'Feature'} Updated Successfully!\n\n`;
            }

            message += `üìù **File Updated:** \`web/src/constants/features.json\`\n\n`;

            // Summary table for multiple features
            if (totalCount > 1) {
              message += `| # | Feature ID | Status | Action |\n`;
              message += `|---|------------|--------|--------|\n`;

              results.forEach(result => {
                const status = result.success ? '‚úÖ' : '‚ùå';
                const action = result.action ? result.action : '-';
                const id = result.id || 'N/A';
                message += `| ${result.index} | \`${id}\` | ${status} | ${action} |\n`;
              });
              message += `\n`;
            }

            // Details for each feature
            results.forEach(result => {
              if (result.success) {
                message += `#### ${totalCount > 1 ? `Feature ${result.index}: ` : ''}\`${result.id}\`\n`;
                message += `- **Action:** ${result.action}\n`;

                // Check translation
                const translation = translationResults.find(t => t.id === result.id);
                if (translation) {
                  if (translation.exists) {
                    message += `- **Translation:** ‚úÖ Found (\`${translation.key}\`)\n`;
                  } else {
                    message += `- **Translation:** ‚ö†Ô∏è Missing (\`${translation.key}\`)\n`;
                  }
                }
                message += `\n`;
              } else {
                message += `#### ${totalCount > 1 ? `Feature ${result.index}: ` : ''}‚ùå Failed\n`;
                message += `- **Error:** ${result.error}\n\n`;
              }
            });

            // Translation instructions if any are missing
            const missingTranslations = translationResults.filter(t => !t.exists);
            if (missingTranslations.length > 0) {
              message += `### ‚ö†Ô∏è Missing Translations\n\n`;
              message += `Please add the following translation keys to:\n`;
              message += `- \`web/src/locales/languages/en.json\`\n`;
              message += `- All other language files\n\n`;
              message += `\`\`\`json\n`;
              message += `{\n`;
              message += `  "about": {\n`;
              missingTranslations.forEach((t, idx) => {
                const comma = idx < missingTranslations.length - 1 ? ',' : '';
                message += `    "feature_${t.id}": "Your Feature Name Here"${comma}\n`;
              });
              message += `  }\n`;
              message += `}\n`;
              message += `\`\`\`\n\n`;
            }

            message += `---\n`;
            message += `ü§ñ ${totalCount > 1 ? 'These features were' : 'This feature was'} automatically ${isPartial ? 'partially ' : ''}processed from your PR description.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });

      - name: Comment on PR - Error
        if: steps.parse-feature.outputs.success == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const error = '${{ steps.parse-feature.outputs.error }}';

            const message = `### ‚ùå Feature Update Failed\n\n` +
              `**Error:** ${error}\n\n` +
              `Please check your feature definition format in the PR description.\n\n` +
              `See the [Feature Update Guide](../../web/src/constants/FEATURES_JSON_GUIDE.md) for the correct format.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });

      - name: Add label
        if: steps.parse-feature.outputs.success == 'true' || steps.parse-feature.outputs.success == 'partial'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['feature-update', 'auto-generated']
            });
