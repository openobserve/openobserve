
  describe("Logs Correlation Tab - CorrelatedLogsTable Integration", () => {
    it("should render CorrelatedLogsTable in logs correlation tab", async () => {
      const mockIncident = createIncidentWithAlerts({
        stable_dimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
          "k8s-deployment": "ebs-csi-controller",
        },
      });

      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
        },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: {
              k8s_namespace_name: "kube-system",
              k8s_deployment_name: "ebs-csi-controller",
            },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      // Switch to logs tab
      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      // Check that CorrelatedLogsTable component is rendered
      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });
      expect(correlatedLogsTable.exists()).toBe(true);
    });

    it("should pass correct props to CorrelatedLogsTable", async () => {
      const mockIncident = createIncidentWithAlerts({
        stable_dimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
        },
      });

      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
        },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: {
              k8s_namespace_name: "kube-system",
              service_name: "test-service",
            },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });
      expect(correlatedLogsTable.props("serviceName")).toBe("test-service");
      expect(correlatedLogsTable.props("sourceStream")).toBe("incidents");
      expect(correlatedLogsTable.props("sourceType")).toBe("incidents");
      expect(correlatedLogsTable.props("hideViewRelatedButton")).toBe(true);
      expect(correlatedLogsTable.props("hideDimensionFilters")).toBe(true);
    });

    it("should hide dimension filters in CorrelatedLogsTable", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: { service_name: "test-service" },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });
      expect(correlatedLogsTable.props("hideDimensionFilters")).toBe(true);
    });
  });

  describe("Field Name Mapping - actualMatchedDimensions", () => {
    it("should map semantic dimensions to actual field names from logStreams filters", async () => {
      const mockIncident = createIncidentWithAlerts({
        stable_dimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
          "k8s-deployment": "ebs-csi-controller",
        },
      });

      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: {
          service: "test-service",
          "k8s-namespace": "kube-system",
          "k8s-deployment": "ebs-csi-controller",
        },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: {
              service_name: "test-service",
              k8s_namespace_name: "kube-system",
              k8s_deployment_name: "ebs-csi-controller",
            },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      // Check that actualMatchedDimensions uses the filters from logStreams
      expect(vm.actualMatchedDimensions).toEqual({
        service_name: "test-service",
        k8s_namespace_name: "kube-system",
        k8s_deployment_name: "ebs-csi-controller",
      });
    });

    it("should pass actualMatchedDimensions to CorrelatedLogsTable", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: {
          "k8s-namespace": "kube-system",
        },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: {
              k8s_namespace_name: "kube-system",
            },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });
      expect(correlatedLogsTable.props("matchedDimensions")).toEqual({
        k8s_namespace_name: "kube-system",
      });
    });

    it("should use availableDimensions from logStreams filters", async () => {
      const mockIncident = createIncidentWithAlerts({
        stable_dimensions: {
          service: "test-service",
          "k8s-pod": "test-pod",
        },
      });

      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: {
              service_name: "test-service",
              k8s_pod_name: "test-pod",
            },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      // Check availableDimensions computed property
      expect(vm.availableDimensions).toEqual({
        service_name: "test-service",
        k8s_pod_name: "test-pod",
      });

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });
      expect(correlatedLogsTable.props("availableDimensions")).toEqual({
        service_name: "test-service",
        k8s_pod_name: "test-pod",
      });
    });

    it("should fallback to matchedDimensions when no logStreams filters available", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;

      // Should fallback to matchedDimensions when no logStreams
      expect(vm.actualMatchedDimensions).toEqual({ service: "test-service" });
    });
  });

  describe("Send to AI Chat Functionality", () => {
    it("should emit sendToAiChat event when CorrelatedLogsTable emits it", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: { service_name: "test-service" },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });

      // Emit sendToAiChat from CorrelatedLogsTable
      const testLogData = { _timestamp: 1234567890, message: "test log" };
      await correlatedLogsTable.vm.$emit("sendToAiChat", testLogData, true);
      await nextTick();

      // Check that parent emitted the event
      expect(wrapper.emitted("sendToAiChat")).toBeTruthy();
      expect(wrapper.emitted("sendToAiChat")?.[0]).toEqual([testLogData, true]);
    });

    it("should handle sendToAiChat with append parameter", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [
          {
            stream_name: "default",
            filters: { service_name: "test-service" },
          },
        ],
        metricStreams: [],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      await nextTick();

      const correlatedLogsTable = wrapper.findComponent({ name: "CorrelatedLogsTable" });

      // Test with append=false
      const testLogData = { _timestamp: 1234567890, message: "test log" };
      await correlatedLogsTable.vm.$emit("sendToAiChat", testLogData, false);
      await nextTick();

      expect(wrapper.emitted("sendToAiChat")).toBeTruthy();
      expect(wrapper.emitted("sendToAiChat")?.[0]).toEqual([testLogData, false]);
    });
  });

  describe("Metrics and Traces Tabs - Dimension Filters", () => {
    it("should hide dimension filters in metrics tab", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [],
        metricStreams: [
          {
            stream_name: "metrics-stream",
            filters: { service_name: "test-service" },
          },
        ],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "metrics";
      await nextTick();

      const telemetryDashboard = wrapper.findComponent({ name: "TelemetryCorrelationDashboard" });
      expect(telemetryDashboard.exists()).toBe(true);
      expect(telemetryDashboard.props("hideDimensionFilters")).toBe(true);
    });

    it("should hide dimension filters in traces tab", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [],
        metricStreams: [],
        traceStreams: [
          {
            stream_name: "traces-stream",
            filters: { service_name: "test-service" },
          },
        ],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "traces";
      await nextTick();

      const telemetryDashboard = wrapper.findComponent({ name: "TelemetryCorrelationDashboard" });
      expect(telemetryDashboard.exists()).toBe(true);
      expect(telemetryDashboard.props("hideDimensionFilters")).toBe(true);
    });

    it("should pass external active tab to TelemetryCorrelationDashboard", async () => {
      const mockIncident = createIncidentWithAlerts();
      const mockCorrelationData = {
        serviceName: "test-service",
        matchedDimensions: { service: "test-service" },
        additionalDimensions: {},
        logStreams: [],
        metricStreams: [
          {
            stream_name: "metrics-stream",
            filters: { service_name: "test-service" },
          },
        ],
        traceStreams: [],
        correlationData: null,
      };

      vi.mocked(incidentsService.get).mockResolvedValue({ data: mockIncident });
      vi.mocked(incidentsService.getCorrelatedStreams).mockResolvedValue(mockCorrelationData);

      wrapper = await createWrapper({}, {}, "incident-1");
      await flushPromises();

      const vm = wrapper.vm as any;
      vm.activeTab = "metrics";
      await nextTick();

      const telemetryDashboard = wrapper.findComponent({ name: "TelemetryCorrelationDashboard" });
      expect(telemetryDashboard.props("externalActiveTab")).toBe("metrics");
    });
  });

  describe("Loading State Centering", () => {
    it("should center loading spinner for logs tab", async () => {
      vi.mocked(incidentsService.get).mockResolvedValue({
        data: createIncidentWithAlerts(),
      });

      // Mock correlation loading
      vi.mocked(incidentsService.getCorrelatedStreams).mockImplementation(
        () => new Promise((resolve) => setTimeout(() => resolve({
          serviceName: "test",
          matchedDimensions: {},
          additionalDimensions: {},
          logStreams: [],
          metricStreams: [],
          traceStreams: [],
          correlationData: null,
        }), 100))
      );

      wrapper = await createWrapper({}, {}, "incident-1");
      await nextTick();

      const vm = wrapper.vm as any;
      vm.activeTab = "logs";
      vm.correlationLoading = true;
      await nextTick();

      // Check for centered loading container
      const loadingContainer = wrapper.find('[class*="tw-items-center"][class*="tw-justify-center"][class*="tw-h-full"]');
      expect(loadingContainer.exists()).toBe(true);
    });

    it("should center loading spinner for metrics tab", async () => {
      vi.mocked(incidentsService.get).mockResolvedValue({
        data: createIncidentWithAlerts(),
      });

      wrapper = await createWrapper({}, {}, "incident-1");
      await nextTick();

      const vm = wrapper.vm as any;
      vm.activeTab = "metrics";
      vm.correlationLoading = true;
      await nextTick();

      const loadingContainer = wrapper.find('[class*="tw-items-center"][class*="tw-justify-center"][class*="tw-h-full"]');
      expect(loadingContainer.exists()).toBe(true);
    });

    it("should center loading spinner for traces tab", async () => {
      vi.mocked(incidentsService.get).mockResolvedValue({
        data: createIncidentWithAlerts(),
      });

      wrapper = await createWrapper({}, {}, "incident-1");
      await nextTick();

      const vm = wrapper.vm as any;
      vm.activeTab = "traces";
      vm.correlationLoading = true;
      await nextTick();

      const loadingContainer = wrapper.find('[class*="tw-items-center"][class*="tw-justify-center"][class*="tw-h-full"]');
      expect(loadingContainer.exists()).toBe(true);
    });
  });
